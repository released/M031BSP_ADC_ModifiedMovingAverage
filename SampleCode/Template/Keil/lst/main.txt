; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ADC_ConvertChannel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  ADC_ConvertChannel PROC
;;;180    
;;;181    uint16_t ADC_ConvertChannel(uint8_t ch)
000000  b53e              PUSH     {r1-r5,lr}
;;;182    {
;;;183    	__IO uint16_t adc_value = 0;
000002  2400              MOVS     r4,#0
000004  4669              MOV      r1,sp
000006  800c              STRH     r4,[r1,#0]
;;;184    	__IO uint16_t duty_value = 0;
000008  808c              STRH     r4,[r1,#4]
;;;185    	__IO uint16_t adcRawData_Target = 0;
00000a  810c              STRH     r4,[r1,#8]
;;;186    
;;;187        /* reload PDMA configuration for next transmission */
;;;188        ReloadPDMA();
00000c  f7fffffe          BL       ReloadPDMA
;;;189    
;;;190    //	ADC_DataReady(1);	
;;;191    
;;;192    	adc_value = ADC_ModifiedMovingAverage(((aADCxConvertedData >>1)<<1));
000010  4d11              LDR      r5,|L1.88|
000012  8868              LDRH     r0,[r5,#2]  ; aADCxConvertedData
000014  0840              LSRS     r0,r0,#1
000016  0040              LSLS     r0,r0,#1
000018  f7fffffe          BL       ADC_ModifiedMovingAverage
00001c  4669              MOV      r1,sp
00001e  8008              STRH     r0,[r1,#0]
;;;193    	
;;;194    	printf("%s : 0x%4X (%d mv)\r\n",__FUNCTION__,adc_value , ADC_CALC_DATA_TO_VOLTAGE(adc_value,AVdd));
000020  88e8              LDRH     r0,[r5,#6]  ; AVdd
000022  8809              LDRH     r1,[r1,#0]
000024  4348              MULS     r0,r1,r0
000026  490d              LDR      r1,|L1.92|
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4669              MOV      r1,sp
00002e  880a              LDRH     r2,[r1,#0]
000030  4603              MOV      r3,r0
000032  490b              LDR      r1,|L1.96|
000034  a00b              ADR      r0,|L1.100|
000036  f7fffffe          BL       __2printf
;;;195    //	printf("%s : %d\r\n",__FUNCTION__, ADC_ReadAVdd());
;;;196    
;;;197    	
;;;198    	if (adc_value <= ADC_CONVERT_TARGET)
00003a  4669              MOV      r1,sp
00003c  8808              LDRH     r0,[r1,#0]
00003e  2800              CMP      r0,#0
000040  d100              BNE      |L1.68|
;;;199    	{
;;;200    		adc_value = ADC_CONVERT_TARGET;
000042  800c              STRH     r4,[r1,#0]
                  |L1.68|
;;;201    	}
;;;202    
;;;203    	if (adc_value >= ADC_RESOLUTION)
000044  8809              LDRH     r1,[r1,#0]
000046  2001              MOVS     r0,#1
000048  0300              LSLS     r0,r0,#12
00004a  4281              CMP      r1,r0
00004c  d301              BCC      |L1.82|
;;;204    	{
;;;205    		adc_value = ADC_RESOLUTION;
00004e  4669              MOV      r1,sp
000050  8008              STRH     r0,[r1,#0]
                  |L1.82|
;;;206    	}
;;;207    
;;;208        /* Stop ADC conversion */
;;;209    //    ADC_STOP_CONV(ADC);
;;;210    
;;;211        /* Disable PDMA function of ADC */
;;;212    //    ADC_DISABLE_PDMA(ADC);
;;;213    
;;;214    	return adc_value;
000052  4668              MOV      r0,sp
000054  8800              LDRH     r0,[r0,#0]
;;;215    }
000056  bd3e              POP      {r1-r5,pc}
;;;216    
                          ENDP

                  |L1.88|
                          DCD      ||.data||
                  |L1.92|
                          DCD      0x00000fff
                  |L1.96|
                          DCD      ||.constdata||
                  |L1.100|
000064  2573203a          DCB      "%s : 0x%4X (%d mv)\r\n",0
000068  20307825
00006c  34582028
000070  2564206d
000074  76290d0a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.ADC_DataReady||, CODE, READONLY, ALIGN=2

                  ADC_DataReady PROC
;;;131    
;;;132    void ADC_DataReady(uint8_t on)
000000  4901              LDR      r1,|L2.8|
;;;133    {
;;;134    	ADCDataReady = on;
000002  7008              STRB     r0,[r1,#0]
;;;135    }
000004  4770              BX       lr
;;;136    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.ADC_IRQHandler||, CODE, READONLY, ALIGN=2

                  ADC_IRQHandler PROC
;;;81     
;;;82     void ADC_IRQHandler(void)
000000  4902              LDR      r1,|L3.12|
;;;83     {
;;;84         g_u32AdcIntFlag = 1;
000002  2001              MOVS     r0,#1
000004  6148              STR      r0,[r1,#0x14]  ; g_u32AdcIntFlag
;;;85         ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT); /* Clear the A/D interrupt flag */
000006  4902              LDR      r1,|L3.16|
000008  6108              STR      r0,[r1,#0x10]
;;;86     }
00000a  4770              BX       lr
;;;87     
                          ENDP

                  |L3.12|
                          DCD      ||.data||
                  |L3.16|
                          DCD      0x40043080

                          AREA ||i.ADC_InitChannel||, CODE, READONLY, ALIGN=2

                  ADC_InitChannel PROC
;;;216    
;;;217    void ADC_InitChannel(uint8_t ch)
000000  b5f8              PUSH     {r3-r7,lr}
;;;218    {
000002  4606              MOV      r6,r0
;;;219    	ADC_ReadAVdd();
000004  f7fffffe          BL       ADC_ReadAVdd
;;;220    
;;;221        /* Enable ADC converter */
;;;222        ADC_POWER_ON(ADC);
000008  4c17              LDR      r4,|L4.104|
00000a  6820              LDR      r0,[r4,#0]
00000c  2501              MOVS     r5,#1
00000e  4328              ORRS     r0,r0,r5
000010  6020              STR      r0,[r4,#0]
000012  4816              LDR      r0,|L4.108|
000014  4916              LDR      r1,|L4.112|
000016  6800              LDR      r0,[r0,#0]  ; CyclesPerUs
000018  4348              MULS     r0,r1,r0
00001a  4916              LDR      r1,|L4.116|
00001c  6148              STR      r0,[r1,#0x14]
00001e  2200              MOVS     r2,#0
000020  618a              STR      r2,[r1,#0x18]
000022  2005              MOVS     r0,#5
000024  6108              STR      r0,[r1,#0x10]
                  |L4.38|
000026  6908              LDR      r0,[r1,#0x10]
000028  03c0              LSLS     r0,r0,#15
00002a  d5fc              BPL      |L4.38|
00002c  610a              STR      r2,[r1,#0x10]
;;;223    
;;;224        /*Wait for ADC internal power ready*/
;;;225        CLK_SysTickDelay(10000);
;;;226    
;;;227        /* Set input mode as single-end, and Single mode*/
;;;228        ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_CONTINUOUS,(uint32_t) BIT0|BIT1);
00002e  4f0e              LDR      r7,|L4.104|
000030  2303              MOVS     r3,#3
000032  3f80              SUBS     r7,r7,#0x80
000034  220c              MOVS     r2,#0xc
000036  2100              MOVS     r1,#0
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       ADC_Open
;;;229    
;;;230        /* To sample band-gap precisely, the ADC capacitor must be charged at least 3 us for charging the ADC capacitor ( Cin )*/
;;;231        /* Sampling time = extended sampling time + 1 */
;;;232        /* 1/24000000 * (Sampling time) = 3 us */
;;;233    	/*
;;;234    	    printf("+----------------------------------------------------------------------+\n");
;;;235    	    printf("|   ADC clock source -> PCLK1  = 48 MHz                                |\n");
;;;236    	    printf("|   ADC clock divider          = 2                                     |\n");
;;;237    	    printf("|   ADC clock                  = 48 MHz / 2 = 24 MHz                   |\n");
;;;238    	    printf("|   ADC extended sampling time = 71                                    |\n");
;;;239    	    printf("|   ADC conversion time = 17 + ADC extended sampling time = 88         |\n");
;;;240    	    printf("|   ADC conversion rate = 24 MHz / 88 = 272.7 ksps                     |\n");
;;;241    	    printf("+----------------------------------------------------------------------+\n");
;;;242    	*/
;;;243    
;;;244        /* Set extend sampling time based on external resistor value.*/
;;;245        ADC_SetExtendSampleTime(ADC,(uint32_t) NULL, ADCextendSampling);
00003e  2200              MOVS     r2,#0
000040  4611              MOV      r1,r2
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       ADC_SetExtendSampleTime
;;;246    
;;;247        /* reload PDMA configuration for next transmission */
;;;248        ReloadPDMA();
000048  f7fffffe          BL       ReloadPDMA
;;;249    
;;;250        /* Select ADC input channel */
;;;251        ADC_SET_INPUT_CHANNEL(ADC, 0x1 << ch);
00004c  6860              LDR      r0,[r4,#4]
00004e  40b5              LSLS     r5,r5,r6
000050  6065              STR      r5,[r4,#4]
;;;252    
;;;253        /* ADC enable PDMA transfer */
;;;254        ADC_ENABLE_PDMA(ADC);
000052  6820              LDR      r0,[r4,#0]
000054  1579              ASRS     r1,r7,#21
000056  4308              ORRS     r0,r0,r1
000058  6020              STR      r0,[r4,#0]
;;;255    
;;;256        /* Start ADC conversion */
;;;257        ADC_START_CONV(ADC);
00005a  6820              LDR      r0,[r4,#0]
00005c  0089              LSLS     r1,r1,#2
00005e  4308              ORRS     r0,r0,r1
000060  6020              STR      r0,[r4,#0]
;;;258    
;;;259    	ADC_MMA_Initial();
000062  f7fffffe          BL       ADC_MMA_Initial
;;;260    	
;;;261    }
000066  bdf8              POP      {r3-r7,pc}
;;;262    
                          ENDP

                  |L4.104|
                          DCD      0x40043080
                  |L4.108|
                          DCD      CyclesPerUs
                  |L4.112|
                          DCD      0x00002710
                  |L4.116|
                          DCD      0xe000e000

                          AREA ||i.ADC_MMA_Initial||, CODE, READONLY, ALIGN=2

                  ADC_MMA_Initial PROC
;;;172    
;;;173    void ADC_MMA_Initial(void)
000000  4803              LDR      r0,|L5.16|
;;;174    {
;;;175    	ADCDataState = ADC_DataState_AVERAGE;
000002  2100              MOVS     r1,#0
000004  7041              STRB     r1,[r0,#1]
;;;176    	movingAverageSum_Target = 0;
;;;177    	movingAverage_Target = 0;
000006  6101              STR      r1,[r0,#0x10]  ; movingAverageSum_Target
000008  8081              STRH     r1,[r0,#4]
00000a  7001              STRB     r1,[r0,#0]
;;;178    	ADC_DataReady(0);
;;;179    }
00000c  4770              BX       lr
;;;180    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      ||.data||

                          AREA ||i.ADC_ModifiedMovingAverage||, CODE, READONLY, ALIGN=2

                  ADC_ModifiedMovingAverage PROC
;;;136    
;;;137    uint16_t ADC_ModifiedMovingAverage(uint16_t data)
000000  4b12              LDR      r3,|L6.76|
000002  7819              LDRB     r1,[r3,#0]  ; ADCDataReady
;;;138    {
;;;139    	static uint16_t cnt = 0;
;;;140    
;;;141    	if (Is_ADC_DataReady())
000004  2900              CMP      r1,#0
000006  d01f              BEQ      |L6.72|
;;;142    	{
;;;143    		ADC_DataReady(0);
000008  2100              MOVS     r1,#0
00000a  7019              STRB     r1,[r3,#0]
;;;144    		
;;;145    //		printf("data : %d\r\n" , data);
;;;146    		
;;;147    		switch(ADCDataState)
00000c  785a              LDRB     r2,[r3,#1]  ; ADCDataState
00000e  4619              MOV      r1,r3
;;;148    		{
;;;149    			case ADC_DataState_AVERAGE:
;;;150    				movingAverageSum_Target += data;
000010  6909              LDR      r1,[r1,#0x10]
000012  2a00              CMP      r2,#0                 ;147
000014  d002              BEQ      |L6.28|
000016  2a01              CMP      r2,#1                 ;147
000018  d116              BNE      |L6.72|
00001a  e00e              B        |L6.58|
                  |L6.28|
00001c  1809              ADDS     r1,r1,r0
;;;151    				if (cnt++ >= (ADC_SAMPLE_COUNT-1))
00001e  6119              STR      r1,[r3,#0x10]  ; movingAverageSum_Target
000020  8918              LDRH     r0,[r3,#8]  ; cnt
000022  1c42              ADDS     r2,r0,#1
000024  811a              STRH     r2,[r3,#8]
000026  280f              CMP      r0,#0xf
000028  d30e              BCC      |L6.72|
;;;152    				{
;;;153    					cnt = 0;
00002a  2000              MOVS     r0,#0
00002c  8118              STRH     r0,[r3,#8]
;;;154    					movingAverage_Target = movingAverageSum_Target >> ADC_SAMPLE_POWER ;	//	/ADC_SAMPLE_COUNT;;
00002e  0308              LSLS     r0,r1,#12
000030  0c00              LSRS     r0,r0,#16
000032  8098              STRH     r0,[r3,#4]
;;;155    					ADCDataState = ADC_DataState_MMA;
000034  2001              MOVS     r0,#1
000036  7058              STRB     r0,[r3,#1]
000038  e006              B        |L6.72|
                  |L6.58|
;;;156    				}			
;;;157    				break;
;;;158    				
;;;159    			case ADC_DataState_MMA:
;;;160    				movingAverageSum_Target -=  movingAverage_Target;
00003a  889a              LDRH     r2,[r3,#4]  ; movingAverage_Target
00003c  1a89              SUBS     r1,r1,r2
;;;161    				movingAverageSum_Target +=  data;
00003e  1808              ADDS     r0,r1,r0
;;;162    				movingAverage_Target = movingAverageSum_Target >> ADC_SAMPLE_POWER ;	//	/ADC_SAMPLE_COUNT;
000040  6118              STR      r0,[r3,#0x10]  ; movingAverageSum_Target
000042  0300              LSLS     r0,r0,#12
000044  0c00              LSRS     r0,r0,#16
000046  8098              STRH     r0,[r3,#4]
                  |L6.72|
;;;163    	
;;;164    //				printf("Average : %d\r\n" , movingAverage);
;;;165    				break;				
;;;166    		}
;;;167    	}	
;;;168    
;;;169    	return movingAverage_Target;
000048  8898              LDRH     r0,[r3,#4]  ; movingAverage_Target
;;;170    }
00004a  4770              BX       lr
;;;171    
                          ENDP

                  |L6.76|
                          DCD      ||.data||

                          AREA ||i.ADC_ReadAVdd||, CODE, READONLY, ALIGN=2

                  ADC_ReadAVdd PROC
;;;87     
;;;88     void ADC_ReadAVdd(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;89     {
;;;90         int32_t  i32ConversionData;
;;;91         int32_t  i32BuiltInData;
;;;92     
;;;93         ADC_POWER_ON(ADC);
000002  4c24              LDR      r4,|L7.148|
000004  6820              LDR      r0,[r4,#0]
000006  2501              MOVS     r5,#1
000008  4328              ORRS     r0,r0,r5
00000a  6020              STR      r0,[r4,#0]
;;;94         ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE, BIT29);
00000c  4f21              LDR      r7,|L7.148|
00000e  05a6              LSLS     r6,r4,#22
000010  2200              MOVS     r2,#0
000012  3f80              SUBS     r7,r7,#0x80
000014  4633              MOV      r3,r6
000016  4611              MOV      r1,r2
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       ADC_Open
;;;95         ADC_SetExtendSampleTime(ADC, 0, 71);
00001e  2247              MOVS     r2,#0x47
000020  2100              MOVS     r1,#0
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       ADC_SetExtendSampleTime
;;;96         ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
000028  6125              STR      r5,[r4,#0x10]
;;;97         ADC_ENABLE_INT(ADC, ADC_ADF_INT);
00002a  2101              MOVS     r1,#1
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       ADC_EnableInt
000032  4819              LDR      r0,|L7.152|
000034  6006              STR      r6,[r0,#0]
;;;98         NVIC_EnableIRQ(ADC_IRQn);
;;;99         g_u32AdcIntFlag = 0;
000036  4919              LDR      r1,|L7.156|
000038  2000              MOVS     r0,#0
00003a  6148              STR      r0,[r1,#0x14]  ; g_u32AdcIntFlag
;;;100        ADC_START_CONV(ADC);
00003c  6822              LDR      r2,[r4,#0]
00003e  14e0              ASRS     r0,r4,#19
000040  4302              ORRS     r2,r2,r0
000042  6022              STR      r2,[r4,#0]
000044  460c              MOV      r4,r1                 ;99
                  |L7.70|
;;;101    
;;;102        while(g_u32AdcIntFlag == 0);
000046  6960              LDR      r0,[r4,#0x14]  ; g_u32AdcIntFlag
000048  2800              CMP      r0,#0
00004a  d0fc              BEQ      |L7.70|
;;;103        ADC_DISABLE_INT(ADC, ADC_ADF_INT);
00004c  2101              MOVS     r1,#1
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       ADC_DisableInt
;;;104    		
;;;105        i32ConversionData = ADC_GET_CONVERSION_DATA(ADC, 29);
000054  480f              LDR      r0,|L7.148|
000056  3840              SUBS     r0,r0,#0x40
000058  6b40              LDR      r0,[r0,#0x34]
00005a  b287              UXTH     r7,r0
;;;106        SYS_UnlockReg();
00005c  f7fffffe          BL       SYS_UnlockReg
;;;107        FMC_Open();
000060  f7fffffe          BL       FMC_Open
000064  480e              LDR      r0,|L7.160|
000066  2104              MOVS     r1,#4
000068  60c1              STR      r1,[r0,#0xc]
00006a  2170              MOVS     r1,#0x70
00006c  6041              STR      r1,[r0,#4]
00006e  6105              STR      r5,[r0,#0x10]
                  |L7.112|
000070  6901              LDR      r1,[r0,#0x10]
000072  07c9              LSLS     r1,r1,#31
000074  d1fc              BNE      |L7.112|
000076  6880              LDR      r0,[r0,#8]
;;;108        i32BuiltInData = FMC_ReadBandGap();	
;;;109    
;;;110    //	printf("%s : %d,%d\r\n",__FUNCTION__, i32ConversionData,i32BuiltInData);
;;;111    
;;;112    	AVdd = 3072*i32BuiltInData/i32ConversionData;
000078  2103              MOVS     r1,#3
00007a  0500              LSLS     r0,r0,#20
00007c  0d00              LSRS     r0,r0,#20
00007e  0289              LSLS     r1,r1,#10
000080  4348              MULS     r0,r1,r0
000082  4639              MOV      r1,r7
000084  f7fffffe          BL       __aeabi_idivmod
000088  80e0              STRH     r0,[r4,#6]
00008a  4803              LDR      r0,|L7.152|
00008c  3080              ADDS     r0,r0,#0x80
00008e  6006              STR      r6,[r0,#0]
;;;113    
;;;114        NVIC_DisableIRQ(ADC_IRQn);
;;;115    	
;;;116    }
000090  bdf8              POP      {r3-r7,pc}
;;;117    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      0x40043080
                  |L7.152|
                          DCD      0xe000e100
                  |L7.156|
                          DCD      ||.data||
                  |L7.160|
                          DCD      0x4000c000

                          AREA ||i.Is_ADC_DataReady||, CODE, READONLY, ALIGN=2

                  Is_ADC_DataReady PROC
;;;126    
;;;127    uint8_t Is_ADC_DataReady(void)
000000  4801              LDR      r0,|L8.8|
;;;128    {
;;;129    	return ADCDataReady;
000002  7800              LDRB     r0,[r0,#0]  ; ADCDataReady
;;;130    }
000004  4770              BX       lr
;;;131    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  PDMA_IRQHandler PROC
;;;262    
;;;263    void PDMA_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;264    {
;;;265        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  4c0e              LDR      r4,|L9.60|
000004  69e0              LDR      r0,[r4,#0x1c]
;;;266    
;;;267        if(status & PDMA_INTSTS_ABTIF_Msk)    /* abort */
;;;268        {
;;;269            if(PDMA_GET_ABORT_STS(PDMA) & PDMA_ABTSTS_ABTIF1_Msk)
;;;270            {
;;;271    			printf("%s abort\r\n" , __FUNCTION__);
;;;272            }
;;;273            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_ABTSTS_ABTIF1_Msk);
000006  2502              MOVS     r5,#2
000008  07c1              LSLS     r1,r0,#31             ;267
00000a  2900              CMP      r1,#0                 ;267
00000c  d008              BEQ      |L9.32|
00000e  6a20              LDR      r0,[r4,#0x20]         ;269
000010  0780              LSLS     r0,r0,#30             ;269
000012  d503              BPL      |L9.28|
000014  490a              LDR      r1,|L9.64|
000016  a00b              ADR      r0,|L9.68|
000018  f7fffffe          BL       __2printf
                  |L9.28|
00001c  6225              STR      r5,[r4,#0x20]
;;;274        }
;;;275        else if(status & PDMA_INTSTS_TDIF_Msk)      /* done */
;;;276        {
;;;277            if(PDMA_GET_TD_STS(PDMA) & PDMA_TDSTS_TDIF1_Msk)
;;;278            {
;;;279    //			printf("%s done\r\n" , __FUNCTION__);
;;;280    			ADC_DataReady(1);
;;;281            }
;;;282            PDMA_CLR_TD_FLAG(PDMA, PDMA_TDSTS_TDIF1_Msk);
;;;283        }
;;;284        else
;;;285            printf("unknown PDMA interrupt !!\n");
;;;286    }
00001e  bd70              POP      {r4-r6,pc}
                  |L9.32|
000020  0780              LSLS     r0,r0,#30             ;275
000022  d507              BPL      |L9.52|
000024  6a60              LDR      r0,[r4,#0x24]         ;277
000026  0780              LSLS     r0,r0,#30             ;277
000028  d502              BPL      |L9.48|
00002a  4909              LDR      r1,|L9.80|
00002c  2001              MOVS     r0,#1                 ;280
00002e  7008              STRB     r0,[r1,#0]            ;280
                  |L9.48|
000030  6265              STR      r5,[r4,#0x24]         ;282
000032  bd70              POP      {r4-r6,pc}
                  |L9.52|
000034  a007              ADR      r0,|L9.84|
000036  f7fffffe          BL       __2printf
00003a  bd70              POP      {r4-r6,pc}
;;;287    
                          ENDP

                  |L9.60|
                          DCD      0x40008400
                  |L9.64|
                          DCD      ||.constdata||+0x13
                  |L9.68|
000044  25732061          DCB      "%s abort\r\n",0
000048  626f7274
00004c  0d0a00  
00004f  00                DCB      0
                  |L9.80|
                          DCD      ||.data||
                  |L9.84|
000054  756e6b6e          DCB      "unknown PDMA interrupt !!\n",0
000058  6f776e20
00005c  50444d41
000060  20696e74
000064  65727275
000068  70742021
00006c  210a00  
00006f  00                DCB      0

                          AREA ||i.PDMA_Init||, CODE, READONLY, ALIGN=2

                  PDMA_Init PROC
;;;287    
;;;288    void PDMA_Init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;289    {
;;;290        /* Configure PDMA peripheral mode form ADC to memory */
;;;291        /* Open PDMA Channel 1 based on PDMAchannel setting*/
;;;292        PDMA_Open(PDMA, 1 << PDMAchannel);
000002  4d16              LDR      r5,|L10.92|
000004  2102              MOVS     r1,#2
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       PDMA_Open
;;;293    
;;;294        /* transfer width is half word(16 bit) and transfer count is ADCDatalenght+1 */
;;;295        PDMA_SetTransferCnt(PDMA, PDMAchannel, PDMA_WIDTH_16, ADC_DMA_SAMPLE_COUNT);
00000c  2301              MOVS     r3,#1
00000e  031a              LSLS     r2,r3,#12
000010  4619              MOV      r1,r3
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       PDMA_SetTransferCnt
;;;296    
;;;297        /* Set source address as ADC data register (no increment) and destination address as g_i32ConversionData array (increment) */
;;;298        PDMA_SetTransferAddr(PDMA, PDMAchannel, (uint32_t)&ADC->ADPDMA, PDMA_SAR_FIX, (uint32_t)&aADCxConvertedData, PDMA_DAR_INC);
000018  4911              LDR      r1,|L10.96|
00001a  2400              MOVS     r4,#0
00001c  2303              MOVS     r3,#3
00001e  9100              STR      r1,[sp,#0]
000020  021b              LSLS     r3,r3,#8
000022  4a10              LDR      r2,|L10.100|
000024  9401              STR      r4,[sp,#4]
000026  2101              MOVS     r1,#1
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       PDMA_SetTransferAddr
;;;299    
;;;300        /* Select PDMA request source as ADC RX */
;;;301        PDMA_SetTransferMode(PDMA, PDMAchannel, PDMA_ADC_RX, FALSE, 0);
00002e  2300              MOVS     r3,#0
000030  2214              MOVS     r2,#0x14
000032  2101              MOVS     r1,#1
000034  4628              MOV      r0,r5
000036  9400              STR      r4,[sp,#0]
000038  f7fffffe          BL       PDMA_SetTransferMode
;;;302    
;;;303        /* Set PDMA as single request type for ADC */
;;;304        PDMA_SetBurstType(PDMA, PDMAchannel, PDMA_REQ_SINGLE, 0);
00003c  2300              MOVS     r3,#0
00003e  2204              MOVS     r2,#4
000040  2101              MOVS     r1,#1
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       PDMA_SetBurstType
;;;305    
;;;306        PDMA_EnableInt(PDMA, PDMAchannel, PDMA_INT_TRANS_DONE);
000048  2200              MOVS     r2,#0
00004a  2101              MOVS     r1,#1
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       PDMA_EnableInt
000052  4905              LDR      r1,|L10.104|
000054  02e8              LSLS     r0,r5,#11
000056  6008              STR      r0,[r1,#0]
;;;307        NVIC_EnableIRQ(PDMA_IRQn);
;;;308    
;;;309    
;;;310    }
000058  bd7c              POP      {r2-r6,pc}
;;;311    
                          ENDP

00005a  0000              DCW      0x0000
                  |L10.92|
                          DCD      0x40008000
                  |L10.96|
                          DCD      ||.data||+0x2
                  |L10.100|
                          DCD      0x40043100
                  |L10.104|
                          DCD      0xe000e100

                          AREA ||i.ReloadPDMA||, CODE, READONLY, ALIGN=2

                  ReloadPDMA PROC
;;;117    
;;;118    void ReloadPDMA(void)
000000  b538              PUSH     {r3-r5,lr}
;;;119    {
;;;120        /* transfer width is half word(16 bit) and transfer count is ADCDatalenght+1 */
;;;121        PDMA_SetTransferCnt(PDMA, PDMAchannel, PDMA_WIDTH_16, ADC_DMA_SAMPLE_COUNT);
000002  2301              MOVS     r3,#1
000004  4c07              LDR      r4,|L11.36|
000006  031a              LSLS     r2,r3,#12
000008  4619              MOV      r1,r3
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       PDMA_SetTransferCnt
;;;122    
;;;123        /* Select PDMA request source as ADC RX */
;;;124        PDMA_SetTransferMode(PDMA, PDMAchannel, PDMA_ADC_RX, FALSE, (uint32_t) NULL);
000010  2100              MOVS     r1,#0
000012  460b              MOV      r3,r1
000014  9100              STR      r1,[sp,#0]
000016  2214              MOVS     r2,#0x14
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       PDMA_SetTransferMode
;;;125    }
000020  bd38              POP      {r3-r5,pc}
;;;126    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x40008000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;363    
;;;364    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
;;;366        /* Unlock protected registers */
;;;367        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;368    
;;;369        /* Enable HIRC clock (Internal RC 48MHz) */
;;;370        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;371    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;372    	
;;;373        /* Wait for HIRC clock ready */
;;;374        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;375    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;376    	
;;;377        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;378        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;379    
;;;380        /* Enable UART0 clock */
;;;381        CLK_EnableModuleClock(UART0_MODULE);
00001a  4c20              LDR      r4,|L12.156|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       CLK_EnableModuleClock
;;;382        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000022  2101              MOVS     r1,#1
000024  2200              MOVS     r2,#0
000026  0689              LSLS     r1,r1,#26
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       CLK_SetModuleClock
;;;383    	
;;;384        CLK_EnableModuleClock(TMR3_MODULE);
00002e  4d1c              LDR      r5,|L12.160|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       CLK_EnableModuleClock
;;;385        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000036  2401              MOVS     r4,#1
000038  0564              LSLS     r4,r4,#21
00003a  2200              MOVS     r2,#0
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_SetModuleClock
;;;386    	
;;;387        CLK_EnableModuleClock(ADC_MODULE);	
000044  4d17              LDR      r5,|L12.164|
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;388        CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL2_ADCSEL_PCLK1, CLK_CLKDIV0_ADC(2));
00004c  1162              ASRS     r2,r4,#5
00004e  4621              MOV      r1,r4
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       CLK_SetModuleClock
;;;389        /* Enable PDMA clock source */
;;;390        CLK_EnableModuleClock(PDMA_MODULE);
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       CLK_EnableModuleClock
;;;391    
;;;392    
;;;393        /* Update System Core Clock */
;;;394        SystemCoreClockUpdate();
00005c  f7fffffe          BL       SystemCoreClockUpdate
;;;395    
;;;396        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;397        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000060  0260              LSLS     r0,r4,#9
000062  6bc1              LDR      r1,[r0,#0x3c]
000064  22ff              MOVS     r2,#0xff
000066  0412              LSLS     r2,r2,#16
000068  4391              BICS     r1,r1,r2
00006a  2233              MOVS     r2,#0x33
00006c  0452              LSLS     r2,r2,#17
00006e  1889              ADDS     r1,r1,r2
000070  63c1              STR      r1,[r0,#0x3c]
;;;398                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;399    
;;;400    
;;;401        SYS->GPB_MFPL = (SYS->GPB_MFPL &~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk )) \
000072  6b81              LDR      r1,[r0,#0x38]
000074  0a09              LSRS     r1,r1,#8
000076  0209              LSLS     r1,r1,#8
000078  3111              ADDS     r1,r1,#0x11
00007a  6381              STR      r1,[r0,#0x38]
;;;402                        | (SYS_GPB_MFPL_PB0MFP_ADC0_CH0 | SYS_GPB_MFPL_PB1MFP_ADC0_CH1) ;
;;;403    
;;;404        /* Set PB.0 ~ PB.3 to input mode */
;;;405        GPIO_SetMode(PB, BIT0|BIT1, GPIO_MODE_INPUT);
00007c  4c0a              LDR      r4,|L12.168|
00007e  2200              MOVS     r2,#0
000080  2103              MOVS     r1,#3
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       GPIO_SetMode
;;;406    
;;;407        /* Disable the PB0 ~ PB3 digital input path to avoid the leakage current. */
;;;408        GPIO_DISABLE_DIGITAL_PATH(PB, BIT0|BIT1);
000088  6861              LDR      r1,[r4,#4]
00008a  2203              MOVS     r2,#3
00008c  0412              LSLS     r2,r2,#16
00008e  4311              ORRS     r1,r1,r2
000090  6061              STR      r1,[r4,#4]
000092  4906              LDR      r1,|L12.172|
000094  2000              MOVS     r0,#0
000096  6008              STR      r0,[r1,#0]
;;;409    
;;;410        /* Lock protected registers */
;;;411        SYS_LockReg();
;;;412    }
000098  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

00009a  0000              DCW      0x0000
                  |L12.156|
                          DCD      0x5f803d10
                  |L12.160|
                          DCD      0x5f400005
                  |L12.164|
                          DCD      0x6743fe1c
                  |L12.168|
                          DCD      0x40004040
                  |L12.172|
                          DCD      0x40000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;842      */
;;;843    __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;844    {
;;;845        do {
;;;846            SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L13.24|
;;;847            SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;848            SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L13.10|
00000a  6001              STR      r1,[r0,#0]            ;846
00000c  6002              STR      r2,[r0,#0]            ;847
00000e  6003              STR      r3,[r0,#0]
;;;849        } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L13.10|
;;;850    }
000016  bd10              POP      {r4,pc}
;;;851    
                          ENDP

                  |L13.24|
                          DCD      0x40000100

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;337    
;;;338    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;339    {
;;;340        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L14.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L14.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;341        TIMER_EnableInt(TIMER3);
;;;342        NVIC_EnableIRQ(TMR3_IRQn);	
;;;343        TIMER_Start(TIMER3);
;;;344    }
000028  bd10              POP      {r4,pc}
;;;345    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40051020
                  |L14.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;311    
;;;312    void TMR3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  480d              LDR      r0,|L15.56|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;313    {
00000a  d014              BEQ      |L15.54|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;314    	static uint32_t LOG = 0;
;;;315    	static uint16_t CNT = 0;
;;;316    	static uint16_t CNT_ADC = 0;
;;;317    	
;;;318        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;319        {
;;;320            TIMER_ClearIntFlag(TIMER3);
;;;321    	
;;;322    		if (CNT++ >= 1000)
000010  490a              LDR      r1,|L15.60|
000012  237d              MOVS     r3,#0x7d
000014  8948              LDRH     r0,[r1,#0xa]  ; CNT
000016  00db              LSLS     r3,r3,#3
000018  1c42              ADDS     r2,r0,#1
00001a  814a              STRH     r2,[r1,#0xa]
00001c  2200              MOVS     r2,#0
00001e  4298              CMP      r0,r3
000020  d300              BCC      |L15.36|
;;;323    		{		
;;;324    			CNT = 0;
000022  814a              STRH     r2,[r1,#0xa]
                  |L15.36|
;;;325    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;326    		}
;;;327    
;;;328    		if (CNT_ADC++ >= ADC_SAMPLETIME_MS)
000024  8988              LDRH     r0,[r1,#0xc]  ; CNT_ADC
000026  1c43              ADDS     r3,r0,#1
000028  818b              STRH     r3,[r1,#0xc]
00002a  2814              CMP      r0,#0x14
00002c  d303              BCC      |L15.54|
;;;329    		{		
;;;330    			CNT_ADC = 0;
00002e  818a              STRH     r2,[r1,#0xc]
;;;331    			ADC_ConvertChannel(ADC0_CH0);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       ADC_ConvertChannel
                  |L15.54|
;;;332    		}
;;;333    		
;;;334        }
;;;335    }
000036  bd10              POP      {r4,pc}
;;;336    
                          ENDP

                  |L15.56|
                          DCD      0x40051020
                  |L15.60|
                          DCD      ||.data||

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;346    
;;;347    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;348    {
;;;349        SYS_ResetModule(UART0_RST);
000002  4813              LDR      r0,|L16.80|
000004  f7fffffe          BL       SYS_ResetModule
;;;350    
;;;351        /* Configure UART0 and set UART0 baud rate */
;;;352        UART_Open(UART0, 115200);
000008  21e1              MOVS     r1,#0xe1
00000a  0249              LSLS     r1,r1,#9
00000c  4811              LDR      r0,|L16.84|
00000e  f7fffffe          BL       UART_Open
;;;353    
;;;354    	/* Set UART receive time-out */
;;;355    //	UART_SetTimeoutCnt(UART0, 20);
;;;356    
;;;357    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000012  f7fffffe          BL       CLK_GetCPUFreq
000016  4601              MOV      r1,r0
000018  a00f              ADR      r0,|L16.88|
00001a  f7fffffe          BL       __2printf
;;;358    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001e  f7fffffe          BL       CLK_GetHXTFreq
000022  4601              MOV      r1,r0
000024  a013              ADR      r0,|L16.116|
000026  f7fffffe          BL       __2printf
;;;359    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00002a  f7fffffe          BL       CLK_GetLXTFreq
00002e  4601              MOV      r1,r0
000030  a016              ADR      r0,|L16.140|
000032  f7fffffe          BL       __2printf
;;;360    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000036  f7fffffe          BL       CLK_GetPCLK0Freq
00003a  4601              MOV      r1,r0
00003c  a019              ADR      r0,|L16.164|
00003e  f7fffffe          BL       __2printf
;;;361    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000042  f7fffffe          BL       CLK_GetPCLK1Freq
000046  4601              MOV      r1,r0
000048  a01d              ADR      r0,|L16.192|
00004a  f7fffffe          BL       __2printf
;;;362    }
00004e  bd10              POP      {r4,pc}
;;;363    
                          ENDP

                  |L16.80|
                          DCD      0x04000010
                  |L16.84|
                          DCD      0x40070000
                  |L16.88|
000058  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00005c  4b5f4765
000060  74435055
000064  46726571
000068  203a2025
00006c  38640d0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L16.116|
000074  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000078  47657448
00007c  58544672
000080  6571203a
000084  20253864
000088  0d0a00  
00008b  00                DCB      0
                  |L16.140|
00008c  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000090  4765744c
000094  58544672
000098  6571203a
00009c  20253864
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L16.164|
0000a4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000a8  47657450
0000ac  434c4b30
0000b0  46726571
0000b4  203a2025
0000b8  38640d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L16.192|
0000c0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000c4  47657450
0000c8  434c4b31
0000cc  46726571
0000d0  203a2025
0000d4  38640d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;421    
;;;422    int main()
000000  f7fffffe          BL       SYS_Init
;;;423    {
;;;424        SYS_Init();
;;;425    
;;;426        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;427    
;;;428    	TIMER3_Init();
000008  f7fffffe          BL       TIMER3_Init
;;;429    
;;;430        PDMA_Init();
00000c  f7fffffe          BL       PDMA_Init
;;;431    
;;;432    	ADC_InitChannel(ADC0_CH0);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       ADC_InitChannel
                  |L17.22|
;;;433    	
;;;434        /* Got no where to go, just loop forever */
;;;435        while(1)
000016  e7fe              B        |L17.22|
;;;436        {
;;;437    
;;;438        }
;;;439    }
;;;440    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  4144435f          DCB      0x41,0x44,0x43,0x5f
000004  436f6e76          DCB      0x43,0x6f,0x6e,0x76
000008  65727443          DCB      0x65,0x72,0x74,0x43
00000c  68616e6e          DCB      0x68,0x61,0x6e,0x6e
000010  656c00            DCB      0x65,0x6c,0x00
                  |symbol_number.57|
000013  50                DCB      0x50
000014  444d415f          DCB      0x44,0x4d,0x41,0x5f
000018  49525148          DCB      0x49,0x52,0x51,0x48
00001c  616e646c          DCB      0x61,0x6e,0x64,0x6c
000020  657200            DCB      0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ADCDataReady
000000  00                DCB      0x00
                  ADCDataState
000001  02                DCB      0x02
                  aADCxConvertedData
000002  0000              DCW      0x0000
                  movingAverage_Target
000004  0000              DCW      0x0000
                  AVdd
000006  0000              DCW      0x0000
                  ||cnt||
000008  0000              DCW      0x0000
                  ||CNT||
00000a  0000              DCW      0x0000
                  CNT_ADC
00000c  0000              DCW      0x0000
00000e  0000              DCB      0x00,0x00
                  movingAverageSum_Target
                          DCD      0x00000000
                  g_u32AdcIntFlag
                          DCD      0x00000000

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  ADC_CH_TypeDef
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_164135a7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____REVSH|
#line 402
|__asm___6_main_c_164135a7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
